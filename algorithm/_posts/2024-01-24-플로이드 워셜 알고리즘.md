---
layout: post
title: '플로이드 워셜 알고리즘'
date: 2024-01-24 00:25:24 +0900
categories: algorithm
---

# 플로이드 워셜 알고리즘

-   모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산한다
-   플로이드 워셜 알고리즘은 다익스트라와 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행한다.  
    -> 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.
-   플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다
-   폴로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다
-   각 단계마다 특정한 노드 K를 거쳐 가는 경우를 확인한다.
-   A에서 B로 가는 최단 거리보다 A에서 K를 거쳐 B로 가는 거리가 더 짧은지 검사한다.
-   음의 간선도 사용 가능(그리디 하지 않기 때문)
-   점화식은 다음과 같습니다.  
    => D[A][B] = MIN(D[A][B], D[A][K]+D[K][B])

## 플로이드 워셜 알고리즘 소스코드 예시

```javascript
let INF = 1e9 // 무한을 의미하는 값으로 10억을 설정
let n = 5 // 노드의 개수

// graph[i][j]는 i에서 j로 가기 위한 초기 비용(간선 포함)
let graph = [
    [INF, INF, INF, INF, INF, INF, INF], //인덱스 0번은 사용하지 않음
    [INF, 0, 1, 5, INF, INF], //1번 노드의 간선들
    [INF, 7, 0, 2, 2, INF], //2번 노드의 간선들
    [INF, 2, INF, 0, INF, 6], //3번 노드의 간선들
    [INF, INF, 2, INF, 0, INF], //4번 노드의 간선들
    [INF, INF, INF, 1, INF, 0], //5번 노드의 간선들
]

// 점화식에 따라 플로이드 워셜 알고리즘 수행
for (let k = 1; k <= n; k++) {
    for (let a = 1; a <= n; a++) {
        for (let b = 1; b <= n; b++) {
            let cost = graph[a][k] + graph[k][b]
            graph[a][b] = Math.min(graph[a][b], cost)
        }
    }
}
```
