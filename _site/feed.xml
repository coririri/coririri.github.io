<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ko" /><updated>2024-02-12T01:03:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gomdarachi의 기술블로그</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><entry><title type="html">CSS 애니메이션</title><link href="http://localhost:4000/css/2024-02-12-CSS-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/" rel="alternate" type="text/html" title="CSS 애니메이션" /><published>2024-02-12T00:20:24+09:00</published><updated>2024-02-12T01:03:29+09:00</updated><id>http://localhost:4000/css/CSS%20%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98</id><content type="html" xml:base="http://localhost:4000/css/2024-02-12-CSS-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/"><![CDATA[<h2 id="요약">요약</h2>

<p>Css에서 Animation을 구현하는 방법은 크게 2가지가 있다.<br />
transition을 활용하거나, animation을 활용하는 방법이다<br />
이 글에선 2가지 방법을 알아보겠다</p>

<h2 id="정리">정리</h2>

<ol>
  <li>
    <p>transition</p>

    <ul>
      <li>hover나 focus 등.. css가 이전 페이지와 다르게 변화할 때 속성의 변화가 일정 기간에 걸쳐 일어나도록 할 수 있습니다 (auto 값은 예상치 못한 결과를 나타낼 수 있기 때문에 지양)</li>
      <li>animation 설정이 가능한 속성들은 유한하다
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">참고 사이트</a></li>
    </ul>
  </li>
  <li>
    <p>animation</p>
    <ul>
      <li>애니메이션을 나타내는 CSS 스타일과 애니메이션의 중간 상태를 나타내는 키프레임들로 이루어집니다.</li>
      <li>CSS 애니메이션은 기존에 사용되던 스크립트를 이용한 애니메이션 보다 다음 세 가지 장점
        <ol>
          <li>JavaScript를 모르더라도 간단하게 애니메이션을 만들 수 있습니다.</li>
          <li>JavaScript를 이용한 애니메이션은 잘 만들어졌더라도 성능이 좋지 못할때가 있습니다.</li>
          <li>브라우저는 애니메이션의 성능을 효율적으로 최적화할 수 있습니다.</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h2 id="속성들">속성들</h2>

<ol>
  <li>transition
    <ul>
      <li>transition-property
트랜지션을 적용해야 하는 CSS 속성의 이름 혹은 이름들을 명시</li>
      <li>transition-duration
트랜지션이 일어나는 지속 시간을 명시</li>
      <li>transition-timing-function
속성의 중간값을 계산하는 방법을 정의하는 함수를 명시
transition-delay
속성이 변한 시점과 트랜지션이 실제로 시작하는 사이에 기다리는 시간을 정의</li>
    </ul>
  </li>
  <li>
    <p>animation</p>

    <ul>
      <li>animation-delay
엘리먼트가 로드되고 나서 언제 애니메이션이 시작될지 지정합니다.</li>
      <li>animation-direction
애니메이션이 종료되고 다시 처음부터 시작할지 역방향으로 진행할지 지정합니다.</li>
      <li>animation-duration
한 싸이클의 애니메이션이 얼마에 걸쳐 일어날지 지정합니다.</li>
      <li>animation-iteration-count
애니메이션이 몇 번 반복될지 지정합니다. infinite로 지정하여 무한히 반복</li>
      <li>animation-name
이 애니메이션의 중간 상태를 지정합니다. 중간 상태는 @keyframes 규칙을 이용하여 기술합니다.</li>
      <li>animation-play-state
애니메이션을 멈추거나 다시 시작할 수 있습니다.</li>
      <li>animation-timing-function
중간 상태들의 전환을 어떤 시간간격으로 진행할지 지정합니다.</li>
      <li>animation-fill-mode
애니메이션이 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정합니다.</li>
    </ul>
  </li>
</ol>

<h2 id="그외">그외</h2>

<ol>
  <li>
    <p>transiton</p>

    <ul>
      <li>transition 완료를 감지하는 event가 있다</li>
    </ul>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">el</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span>
    <span class="dl">'</span><span class="s1">transitionend</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">updateTransition</span><span class="p">,</span>
    <span class="kc">true</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>animation</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 애니메이션의 중간상태 기술하기
  @keyframes 규칙을 이용해서 두개 이상의 중간 상태를 기술합니다. 각 중간 상태는 특정 시점에 엘리먼트가 어떻게 보일지 나타냅니다. (중간 상태는 &lt;percentage&gt; 를 이용해 지정합니다.)
- 0%는 애니메이션이 시작된 시점을 의미하고 100%는 애니메이션이 끝나는 시점을 의미 ( 0%와 100% 대신 from 과 to로 사용할 수도 있습니다.)

```javascript
p {

animation-duration: 3s;
animation-name: slidein;
}

@keyframes slidein {
from {
margin-left: 100%;
width: 300%;
}

to {
margin-left: 0%;
width: 100%;
}
}
```

- animation을 감지하는 event가 있다

```javascript
function setup() {
    var e = document.getElementById('watchme')
    e.addEventListener(
        'animationstart',
        listener,
        false
    )
    e.addEventListener('animationend', listener, false)
    e.addEventListener(
        'animationiteration',
        listener,
        false
    )

    var e = document.getElementById('watchme')
    e.className = 'slidein'
}

function listener(e) {

var l = document.createElement("li");
switch (e.type) {
case "animationstart":
l.innerHTML = "Started: elapsed time is " + e.elapsedTime;
break;
case "animationend":
l.innerHTML = "Ended: elapsed time is " + e.elapsedTime;
break;
case "animationiteration":
l.innerHTML = "New loop started at time " + e.elapsedTime;
break;
}
document.getElementById("output").appendChild(l);
}
```
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="css" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">타입스크립트와 PropTypes</title><link href="http://localhost:4000/haanppen/2024-02-08-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-PropTypes/" rel="alternate" type="text/html" title="타입스크립트와 PropTypes" /><published>2024-02-08T00:01:24+09:00</published><updated>2024-02-11T16:44:41+09:00</updated><id>http://localhost:4000/haanppen/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80%20PropTypes</id><content type="html" xml:base="http://localhost:4000/haanppen/2024-02-08-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-PropTypes/"><![CDATA[<h2 id="요약">요약</h2>

<p>리액트 프로젝트의 타입 검사를 하는 방법을 결정하기 위해 조사 한 글</p>

<h2 id="서론">서론</h2>

<ol>
  <li>타입스크립트</li>
  <li>PropTypes
두가지 방식으로 타입을 체크하는데 두 방식의 장던짐이 있다.</li>
</ol>

<h2 id="본론">본론</h2>

<ul>
  <li>타입스크립트</li>
</ul>

<ol>
  <li>타입스크립트가 자바스크립트로 변환되는 컴파일 시점에 타입 체크 오류를 발생시킨다</li>
  <li>PropTypes보다 더 성능이 뛰어난 자동화 도구가 존재하고, 많은 타입을 지원한다</li>
</ol>

<ul>
  <li>PropTypes</li>
</ul>

<ol>
  <li>런타임 시점에서 타입 체크 오류를 발생 시킨다 (많은 사람들이 사용하는 라이브러리를 제작시 사용 권장)</li>
  <li>런타임 시점에서 오류가 발생하기 때문에, API 데이터들도 타입 체크를 할 수 있다</li>
  <li>부족한 자동화 도구, 적은 타입이 단점이다</li>
</ol>

<h2 id="결론">결론</h2>

<p>PropTypes를 사용하기로 했다. 이유는 런타임 데이터 체크도 해보고 싶고, 아직 한번도 써보지 못한 대중적인 툴이기 때문이다.</p>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="haanppen" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">폴더구조와 디자인 패턴</title><link href="http://localhost:4000/haanppen/2024-02-06-%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="폴더구조와 디자인 패턴" /><published>2024-02-06T21:26:24+09:00</published><updated>2024-02-06T17:38:25+09:00</updated><id>http://localhost:4000/haanppen/%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0%EC%99%80%20%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4</id><content type="html" xml:base="http://localhost:4000/haanppen/2024-02-06-%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"><![CDATA[<h2 id="요약">요약</h2>

<p>CRA로 시작한 리액트 프로젝트의 components 폴더 내부 구조를 어떻게 결정할지에 대한 고민 글</p>

<h2 id="서론">서론</h2>

<ol>
  <li>Atomic Component 디자인 패턴</li>
  <li>Micro Atomic Component 디자인 패턴</li>
  <li>디자인 패턴 X
이렇게 3가지의 방법에 대해서 선택해야 했다<br />
2번같은 경우는 1번과 동일하지만 페이지마다 따로따로 관리하는 하는 방식이다<br />
따라서 페이지가 많은 경우 파일 관리가 효율적으로 될 꺼 같았다</li>
</ol>

<h2 id="본론">본론</h2>

<p>우선 폴더 구조의 디자인 패턴은 후임 개발자의 유지보수를 용이하게 함과 개발하면서 스스로 폴더 구조를 잘 파악해<br />
개발 중 햇 갈림 요소를 없애는 용도이다.<br />
따라서 난 꼭 한가지 방법은 도입하고 싶었다<br />
사실 이번 프로젝트의 규모가 크지는 않다고 생각해서 1번 Atimic Component 디자인 패턴으로 결정하게 되었다</p>

<h2 id="결론">결론</h2>

<p>1번으로 결정했지만, 개발 도중 부족함이 생기거나 문제점이 생기면 유연하게 바꿔가면서 개발 할 생각이다<br />
실제로 디자인 패턴은 개발자를 위한 도구이기 때문에 크게 얽매일 필요는 없는거 같다.</p>

<h2 id="참고-자료">참고 자료</h2>

<p><img src="https://yozm.wishket.com/magazine/detail/1531/" alt="개인 블로그 글" /></p>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="haanppen" /><summary type="html"><![CDATA[요약]]></summary></entry><entry><title type="html">누적 합 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-24-%EB%88%84%EC%A0%81%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98y/" rel="alternate" type="text/html" title="누적 합 알고리즘" /><published>2024-01-24T01:20:24+09:00</published><updated>2024-01-24T01:43:40+09:00</updated><id>http://localhost:4000/algorithm/%EB%88%84%EC%A0%81%ED%95%A9%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98y</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-24-%EB%88%84%EC%A0%81%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98y/"><![CDATA[<h2 id="대표적인-예시">대표적인 예시</h2>

<p>구간 합 문제: 나열된 N개의 수가 있을 때 특정 구간희 모든 수를 합한 값을 계산하는 문제</p>

<ul>
  <li>예를 들어 5개의 데이터로 구성 된 수열 {10, 20, 30, 40 ,50}이 있다고 가정한다</li>
  <li>두번째 수 부터 네 번째 수까지의 합은 20+30+40 = 90이다.</li>
</ul>

<h2 id="누적합-알고리즘-동작-방식">누적합 알고리즘 동작 방식</h2>

<ul>
  <li>N개의 정수로 구성된 수열이 있다.</li>
  <li>N개의 쿼리 정보가 주어진다</li>
  <li>각 쿼리는 Left와 Right로 구성된다.</li>
  <li>각 쿼리에 대하여 [Left, Right] 구건에 포함된 데이터들의 합을 출력해야 한다</li>
  <li>수행 시간 제한은 O(N + M)이다.</li>
</ul>

<h3 id="접두사-합">접두사 합</h3>

<ul>
  <li>배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것</li>
  <li>접두사 합을 활용한 알고리즘은 다음과 같다</li>
  <li>[1, 3] =&gt; p[3] - p[0] = 9</li>
  <li>[3, 5] =&gt; p[5] - p[2] = 7</li>
  <li>[4, 8] =&gt; p[8] - p[3] = 11</li>
</ul>

<h2 id="누적합-알고리즘-코드-예시">누적합 알고리즘 코드 예시</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">8</span>
<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="c1">// 접두사 합(Prefix Sum) 배열 계산</span>
<span class="kd">let</span> <span class="nx">sumValue</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nx">prefixSum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sumValue</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="nx">prefixSum</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">sumValue</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 구간 합 계산(네 번째 수부터 여덟 번째 수까지)</span>
<span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">4</span>
<span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="mi">8</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">prefixSum</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prefixSum</span><span class="p">[</span><span class="nx">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[대표적인 예시]]></summary></entry><entry><title type="html">투 포인터 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-24-%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="투 포인터 알고리즘" /><published>2024-01-24T01:10:24+09:00</published><updated>2024-01-24T01:21:03+09:00</updated><id>http://localhost:4000/algorithm/%ED%88%AC%20%ED%8F%AC%EC%9D%B8%ED%84%B0%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-24-%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<ul>
  <li>리스트에 순차적으로 접근해야 할 때, 두 개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다</li>
  <li>흔히 2, 3, 4, 5, 6, 7번 학생을 지목해야 할 때 간단히 ‘2번부터 7번까지의 학생’이라고 부르곤 한다.</li>
  <li>리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 시작점과 끝점 2개의 점으로 접근 할 데이터의 범위를 표현할 수 있다</li>
</ul>

<h2 id="투-포인터-알고리즘-예시">투 포인터 알고리즘 예시</h2>

<p><img src="../images/투포인터%20예시2.jpg" alt="images" />
<img src="/algorithm/images/%ED%88%AC%ED%8F%AC%EC%9D%B8%ED%84%B0%20%EC%98%88%EC%8B%9C1.jpg" alt="images" /></p>

<h2 id="투-포인터-알고리즘-예시-코드">투 포인터 알고리즘 예시 코드</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1">// 데이터의 개수 N</span>
<span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1">// 찾고자 하는 부분합 M</span>
<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1">// 전체 수열</span>

<span class="kd">let</span> <span class="nx">cnt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nx">intervalSum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nx">end</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1">// start를 차례대로 증가시키며 반복</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">start</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// end를 가능한 만큼 이동시키기</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">intervalSum</span> <span class="o">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">end</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">intervalSum</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">end</span><span class="p">]</span>
        <span class="nx">end</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// 부분합이 m일 때 카운트 증가</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">intervalSum</span> <span class="o">==</span> <span class="nx">m</span><span class="p">)</span> <span class="nx">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nx">intervalSum</span> <span class="o">-=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">cnt</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[리스트에 순차적으로 접근해야 할 때, 두 개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미한다 흔히 2, 3, 4, 5, 6, 7번 학생을 지목해야 할 때 간단히 ‘2번부터 7번까지의 학생’이라고 부르곤 한다. 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 시작점과 끝점 2개의 점으로 접근 할 데이터의 범위를 표현할 수 있다]]></summary></entry><entry><title type="html">벨만 포드 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-24-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="벨만 포드 알고리즘" /><published>2024-01-24T00:49:24+09:00</published><updated>2024-01-24T01:21:16+09:00</updated><id>http://localhost:4000/algorithm/%EB%B2%A8%EB%A7%8C%20%ED%8F%AC%EB%93%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-24-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<h2 id="음수-간선이-포함된-상황에서의-최단-거리-문제">음수 간선이 포함된 상황에서의 최단 거리 문제</h2>

<ol>
  <li>음수 순환은 없는 경우</li>
</ol>

<ul>
  <li>벨만 포드 알고리즘을 사용해서 구하자</li>
</ul>

<ol>
  <li>음수 순환이 있는 경우</li>
</ol>

<ul>
  <li>벨만 포드 알고리즘을 사용해도 못 구한다</li>
  <li>음수 순환을 감지할 수 있다.</li>
</ul>

<h2 id="벨만-포드-알고리즘-시간-복잡도">벨만 포드 알고리즘 시간 복잡도</h2>

<p>O(VE)로 다익스트라 알고리즘보다 느리지만, 다익스트라 알고리즘의 해를 가지고 있다</p>

<h2 id="벨만-포드-알고리즘의-동작-과정">벨만 포드 알고리즘의 동작 과정</h2>

<ol>
  <li>출발 노드를 설정한다</li>
  <li>최단 거리 테이블을 초기화한다.</li>
  <li>다음의 과정을 N-1번 반복한다.</li>
</ol>

<ul>
  <li>전체 간선 E개를 하나씩 확인한다.</li>
  <li>각 간선을 거쳐 다른 노드로 가는 비용을 게산하여 최단 거리 테이블을 갱신한다</li>
  <li>만약 음수 순환이 발생하는지 체크 하고 싶다면 3번의 과정을 한번 더 수행한다.</li>
  <li>이때 최단 거리 테이블이 갱신된다면 음수 순환이 존재하는 것이다.</li>
</ul>

<h2 id="벨만-포드-알고리즘-코드-예시">벨만 포드 알고리즘 코드 예시</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">bf</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 시작 노드에 대해서 초기화</span>
    <span class="nx">dist</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 전체 n번 라운드(round)를 반복</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 매 반복마다 "모든 간선"을 확인하며</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="p">[</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">nextNode</span><span class="p">,</span> <span class="nx">cost</span><span class="p">]</span> <span class="o">=</span> <span class="nx">edges</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="c1">// 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우</span>
            <span class="k">if </span><span class="p">(</span>
                <span class="nx">dist</span><span class="p">[</span><span class="nx">cur</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">INF</span> <span class="o">&amp;&amp;</span>
                <span class="nx">dist</span><span class="p">[</span><span class="nx">nextNode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">dist</span><span class="p">[</span><span class="nx">cur</span><span class="p">]</span> <span class="o">+</span> <span class="nx">cost</span>
            <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// n번째 라운드에서도 값이 갱신된다면 음수 순환이 존재</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">INF</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">e9</span> <span class="c1">// 무한을 의미하는 값으로 10억을 설정</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1">// 노드의 개수</span>
<span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1">// 간선의 개수</span>
<span class="c1">// 모든 간선에 대한 정보를 담는 리스트 만들기</span>
<span class="kd">let</span> <span class="nx">edges</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">//[a, b, c]: a에서 b로 가는 비용이 c라는 의미</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">...</span>
<span class="p">];</span>
<span class="kd">let</span> <span class="nx">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="nx">INF</span><span class="p">)</span> <span class="c1">//최단 거리를 모두 무한으로 초기화</span>
<span class="c1">// 벨만 포드 알고리즘 수행</span>
<span class="kd">let</span> <span class="nx">negativeCycle</span> <span class="o">=</span> <span class="nf">bf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 1번 노드가 시작 노드</span>
<span class="k">if</span><span class="p">(</span><span class="nx">negativeCycle</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">dist</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[음수 간선이 포함된 상황에서의 최단 거리 문제]]></summary></entry><entry><title type="html">플로이드 워셜 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-24-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="플로이드 워셜 알고리즘" /><published>2024-01-24T00:25:24+09:00</published><updated>2024-01-24T01:21:12+09:00</updated><id>http://localhost:4000/algorithm/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EC%9B%8C%EC%85%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-24-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<ul>
  <li>모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산한다</li>
  <li>플로이드 워셜 알고리즘은 다익스트라와 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행한다.<br />
-&gt; 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.</li>
  <li>플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다</li>
  <li>폴로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다</li>
  <li>각 단계마다 특정한 노드 K를 거쳐 가는 경우를 확인한다.</li>
  <li>A에서 B로 가는 최단 거리보다 A에서 K를 거쳐 B로 가는 거리가 더 짧은지 검사한다.</li>
  <li>음의 간선도 사용 가능(그리디 하지 않기 때문)</li>
  <li>점화식은 다음과 같습니다.<br />
=&gt; D[A][B] = MIN(D[A][B], D[A][K]+D[K][B])</li>
</ul>

<h2 id="플로이드-워셜-알고리즘-소스코드-예시">플로이드 워셜 알고리즘 소스코드 예시</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">INF</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">e9</span> <span class="c1">// 무한을 의미하는 값으로 10억을 설정</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1">// 노드의 개수</span>

<span class="c1">// graph[i][j]는 i에서 j로 가기 위한 초기 비용(간선 포함)</span>
<span class="kd">let</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">],</span> <span class="c1">//인덱스 0번은 사용하지 않음</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">],</span> <span class="c1">//1번 노드의 간선들</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">INF</span><span class="p">],</span> <span class="c1">//2번 노드의 간선들</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="c1">//3번 노드의 간선들</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">INF</span><span class="p">],</span> <span class="c1">//4번 노드의 간선들</span>
    <span class="p">[</span><span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="c1">//5번 노드의 간선들</span>
<span class="p">]</span>

<span class="c1">// 점화식에 따라 플로이드 워셜 알고리즘 수행</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">a</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">b</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">cost</span> <span class="o">=</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span> <span class="o">+</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="nx">b</span><span class="p">]</span>
            <span class="nx">graph</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">graph</span><span class="p">[</span><span class="nx">a</span><span class="p">][</span><span class="nx">b</span><span class="p">],</span> <span class="nx">cost</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산한다 플로이드 워셜 알고리즘은 다익스트라와 마찬가지로 단계별로 거쳐가는 노드를 기준으로 알고리즘을 수행한다. -&gt; 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다. 플로이드 워셜은 2차원 테이블에 최단 거리 정보를 저장한다 폴로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다 각 단계마다 특정한 노드 K를 거쳐 가는 경우를 확인한다. A에서 B로 가는 최단 거리보다 A에서 K를 거쳐 B로 가는 거리가 더 짧은지 검사한다. 음의 간선도 사용 가능(그리디 하지 않기 때문) 점화식은 다음과 같습니다. =&gt; D[A][B] = MIN(D[A][B], D[A][K]+D[K][B])]]></summary></entry><entry><title type="html">다익스트라 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-23-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="다익스트라 알고리즘" /><published>2024-01-23T19:08:24+09:00</published><updated>2024-01-24T00:24:38+09:00</updated><id>http://localhost:4000/algorithm/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-23-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<p>한 지점에서 다른 모든 지점까지의 최단 경로<br />
간선은 양수여야한다(그리디 알고리즘을 만족하지 못함), (음의 순환 방지)
=&gt; 벨만 포드로 해결<br />
그리디 알고리즘으로 분류 된다. (매 상황에서 가장 비용이 적은 노드를 선택해 반복한다)</p>

<h2 id="다익스트라-알고리즘-동작-과정">다익스트라 알고리즘 동작 과정</h2>

<ol>
  <li>출발 노드를 설정한다.</li>
  <li>최단 거리 테이블을 초기화한다.</li>
  <li>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.</li>
  <li>해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다<br />
-&gt; 최단 거리 테이블은 직접 갱신하지 않고, 우선순위 큐에 삽입하는 방식을 사용한다.</li>
  <li>위 과정에서 3번과 4번을 반복한다.</li>
</ol>

<h3 id="다익스트라-알고리즘의-특징">다익스트라 알고리즘의 특징</h3>

<ul>
  <li>단계를 거치며 한 번 처리된 노드의 최단 거리를 고정되어 더 이상 바뀌지 않는다.<br />
결국 현재 가장 가까운 노드는 현재 경로가 가장 빠른 이유가, 결국 다른 노드를 거쳐서 가야하기 때문이다.</li>
  <li>한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다.</li>
  <li>완전한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능(BFS로 추적)을 더 넣어야 한다.</li>
  <li>단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다</li>
  <li>이를 위해 힙(Heap) 자료구조를 이용한다.</li>
</ul>

<h2 id="다익스트라-알고리즘-코드">다익스트라 알고리즘 코드</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">dijkstra</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//다익스트라 알고리즘 수행</span>
    <span class="kd">let</span> <span class="nx">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// 최소 힙</span>
    <span class="c1">// 시작 노드로 가기 위한 최단 거리를 0으로 우선 순위 큐에 삽입</span>
    <span class="nx">pq</span><span class="p">.</span><span class="nf">enq</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nx">start</span><span class="p">])</span>
    <span class="nx">distance</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">pq</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 우선순위 큐가 비어있지 않다면</span>
        <span class="c1">// 가장  최단 거리가 짧은 노드에 대한 정보 꺼내기</span>
        <span class="kd">let</span> <span class="p">[</span><span class="nx">dist</span><span class="p">,</span> <span class="nx">now</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">dep</span><span class="p">()</span>
        <span class="c1">// 현재 노드가 뒷 큐에 갱신되어 들어 왔다면 무시</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">distance</span><span class="p">[</span><span class="nx">now</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">dist</span><span class="p">)</span> <span class="k">continue</span>
        <span class="c1">// 현재 노드와 연결된 다른 인접한 노드들을 확인</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">now</span><span class="p">])</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">cost</span> <span class="o">=</span> <span class="nx">dist</span> <span class="o">+</span> <span class="nx">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">// 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우</span>
            <span class="c1">// 이미 방문 한 노드는 더 이상 방문 못함(이미 가장 낮은 거리 값으로 갱신 됨)</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">cost</span> <span class="o">&lt;</span> <span class="nx">distance</span><span class="p">[</span><span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="p">{</span>
                <span class="nx">distance</span><span class="p">[</span><span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">cost</span>
                <span class="nx">pq</span><span class="p">.</span><span class="nf">enq</span><span class="p">([</span><span class="nx">cost</span><span class="p">,</span> <span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">INF</span> <span class="o">=</span> <span class="mi">1</span><span class="nx">e9</span> <span class="c1">//무한을 의미하는 값으로 10억을 설정</span>
<span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1">// 노드의 개수</span>
<span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// 시작 노드 번호</span>
<span class="c1">// 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기</span>
<span class="kd">let</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">//각 간선은 [노드, 비용] 형태</span>
    <span class="p">[],</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 1번노드의 간선들</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 2번노드의 간선들</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 3번노드의 간선들</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 4번노드의 간선들</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 5번노드의 간선들</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">],</span> <span class="c1">// 6번노드의 간선들</span>
    <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="c1">// 7번노드의 간선들</span>
<span class="p">]</span>

<span class="c1">// 최단 거리 테이블을 모두 무한으로 초기화</span>
<span class="kd">let</span> <span class="nx">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="nx">INF</span><span class="p">)</span>

<span class="c1">// 다익스트라 알고리즘을 수행</span>
<span class="nf">dijkstra</span><span class="p">()</span>
<span class="c1">// 모든 노드로 가기 위한 최단 거리를 출력</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//도달할 수 없는 경우 무한(INFINITY)이라고 출력</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">distance</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">INF</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">INFINITY</span><span class="dl">'</span><span class="p">)</span>
    <span class="c1">// 도달할 수 있는 경우 거리를 출력</span>
    <span class="k">else</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">distance</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="다익스트라-알고리즘의-시간-복잡도">다익스트라 알고리즘의 시간 복잡도</h2>

<p>힙 자료구조를 이용하는 다익스트라 알고리즘의 시간 복잡도는 O(ElogV)이다.</p>

<ul>
  <li>노드를 하나씩 꺼내 검사하는 반복문 (while문)은 노드의 개수 V 이상의 횟수로는 처리 되지 않는다.</li>
  <li>결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 간선의 개수(E)만큼 연산이 수행될 수 있다.</li>
  <li>직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사하며</li>
  <li>시간 복잡도를 O(ElogE)로 판단할 수 있다.</li>
  <li>중복 간선을 포함하지 않을 경우에 이를 O(ElogV)로 정리할 수 있다.</li>
  <li>O(ElogE) -&gt; O(ElogV^2) -&gt; O(2ElogV) -&gt; O(ElogV)</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[한 지점에서 다른 모든 지점까지의 최단 경로 간선은 양수여야한다(그리디 알고리즘을 만족하지 못함), (음의 순환 방지) =&gt; 벨만 포드로 해결 그리디 알고리즘으로 분류 된다. (매 상황에서 가장 비용이 적은 노드를 선택해 반복한다)]]></summary></entry><entry><title type="html">다이나믹 프로그래밍</title><link href="http://localhost:4000/algorithm/2024-01-23-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/" rel="alternate" type="text/html" title="다이나믹 프로그래밍" /><published>2024-01-23T18:38:24+09:00</published><updated>2024-01-23T19:01:34+09:00</updated><id>http://localhost:4000/algorithm/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-23-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"><![CDATA[<ul>
  <li>메모리를 더 사용하여 시간 복잡도를 개선할 때 많이 사용된다.</li>
  <li>구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적용하면 효과적이다.</li>
  <li>다이나믹 프로그래밍 문제를 해결하기 위해 “점화식”을 찾는 것이 핵심적인 과정이다.</li>
</ul>

<h2 id="다이나믹-프로그래밍의-사용-조건">다이나믹 프로그래밍의 사용 조건</h2>

<p>다이나믹 프로그래밍은 일반적으로 아래의 두 조건을 만족할 때 사용할 수 있다.</p>

<ol>
  <li>최적 부분 구조(optimal substructure)</li>
</ol>

<ul>
  <li>큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.<br />
=&gt; 점화식 형태로 해결 가능</li>
</ul>

<ol>
  <li>반복되는 부분 문제(overlapping sub-problem)<br />
=&gt; DP로 해결</li>
</ol>

<ul>
  <li>동일한 작은 문제를 반복적으로 해결해야 한다.</li>
</ul>

<h2 id="점화식의-구성요소">점화식의 구성요소</h2>

<ol>
  <li>초기항</li>
  <li>인접한 항과의 관계</li>
</ol>

<ul>
  <li>점화식은 [재귀 함수]로 표현할 수 있다.</li>
  <li>재귀 함수는 [종료 조건]이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">fibo</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>DP 사용</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">function</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">d</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">d</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibo</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">d</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">fibo</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="다이나막-프로그래밍의-일반-형태">다이나막 프로그래밍의 일반 형태</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">dp</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1) 종료 조건</span>
    <span class="c1">// 2) 이미 해결한 문제라면, 정답을 그대로 반환</span>
    <span class="c1">// 3) 점화식에 따라 계산</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="다이나믹-프로그래밍-문제-해결-과정">다이나믹 프로그래밍 문제 해결 과정</h2>

<ul>
  <li>접근 순서</li>
</ul>

<ol>
  <li>문제 이해하기</li>
  <li>점화식 찾아내기 -&gt; 일반적으로 가장 핵심적인 부분이다.</li>
  <li>구현 방식(상향식/하햐식) 결정하기</li>
  <li>점화식을 실제 코드로 구현하기</li>
</ol>

<ul>
  <li>상향식
반복문을 이용해 초기 항부터 계산한다.</li>
  <li>하향식
재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식이다.<br />
-&gt; 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라고 한다.</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[메모리를 더 사용하여 시간 복잡도를 개선할 때 많이 사용된다. 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 부분 문제의 반복이 발생하는 경우 적용하면 효과적이다. 다이나믹 프로그래밍 문제를 해결하기 위해 “점화식”을 찾는 것이 핵심적인 과정이다.]]></summary></entry><entry><title type="html">BFS 알고리즘</title><link href="http://localhost:4000/algorithm/2024-01-23-BFS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="BFS 알고리즘" /><published>2024-01-23T16:00:24+09:00</published><updated>2024-01-24T01:09:57+09:00</updated><id>http://localhost:4000/algorithm/BFS%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2024-01-23-BFS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<p>그래프 혹은 트리에서 모든 노드를 한번씩 탐색하기 위한 방법<br />
(모든 간선의 길이가 동일할 때) 최단 거리를 탐색하기 위한 목적으로 사용할 수 있다.
큐 자료구조를 이용한다</p>

<h2 id="dfs와-bfs">DFS와 BFS</h2>

<ul>
  <li>탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정</li>
  <li>DFS와 BFS는 코딩 테스트에서 매우 자주 등장하는 유형이므로 반드시 숙지</li>
</ul>

<h2 id="bfs의-동작방식">BFS의 동작방식</h2>

<ol>
  <li>시작 노드를 큐에 넣고 [방문 처리]한다.</li>
  <li>큐에서 원소를 꺼내어 방문하지 않은 인접 노드가 있는지 확인한다.</li>
</ol>

<ul>
  <li>있다면, 방문하지 않은 인접 노드를 큐에 삽입하고 [방문 처리]한다.</li>
</ul>

<ol>
  <li>2번 과정을 더 이상 반복할 수 없을 때까지 반복한다.</li>
</ol>

<ul>
  <li>실제 알고리즘/코딩 테스트 문제에서는 노드의 번호가 1부터 시작하는 경우가 많다.</li>
</ul>

<h2 id="bfs-사용-예시">BFS 사용 예시</h2>

<ol>
  <li>간선의 비용이 동일한 상황에서 [최단 거리] 문제를 해결하는 경우</li>
  <li>완전 탐색을 위해 사용한 DFS 솔루션이 메모리/시간 초과를 받아 BFS로 재시도하는 경우<br />
-&gt; DFS와 BFS로 모두 그래프 탐색 목적으로 사용할 수 있으나, 구현이 익숙하다면 BFS를 추천</li>
</ol>

<ul>
  <li>코딩 테스트에서 DFS로 해결할 수 있는 문제는 BFS로도 해결할 수 있는 경우가 많다<br />
-&gt; DFS는 일반적인 최단 거리 문제를 해결할 수 없다.</li>
</ul>

<h2 id="bfs와-최단경로">BFS와 최단경로</h2>

<ul>
  <li>BFS는 간선의 비용이 동일할 때 [최단 거리] 문제를 해결하기 위해 사용 가능하다.</li>
  <li>BFS는 다익스트라 최단 경로 알고리즘과 유사한 특징이 있다.<br />
-&gt; 다익스트라는 간선의 비용이 서로 다를 수 있을 때 사용 가능하다.</li>
</ul>

<ol>
  <li>다익스트라 알고리즘은 일반 큐 대신에 우선순위 큐를 사용한다.</li>
  <li>다익스트라는 특정 노드에 대하여 [최단 거리] 값이 갱신될 수 있다. (더 짧은 경로를 찾는 경우)</li>
</ol>

<h2 id="bfs-소스-코드-예시">BFS 소스 코드 예시</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">bfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">game</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">sd</span><span class="dl">'</span>
    <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>
    <span class="c1">// 현재 노드를 방문 처리</span>
    <span class="nx">visited</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="c1">// 큐가 빌 때까지 반복</span>
    <span class="k">while </span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">getLength</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 큐에서 하나의 원소를 뽑아 출력하기</span>
        <span class="nx">v</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="c1">// 아직 방문하지 않은 인접한 원소들을 큐에 삽입</span>
        <span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 각 노드가 연결된 정보를 표현</span>
<span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="nx">s</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1">// 각 노드가 방문한 정보를 표현</span>
<span class="nx">visiteid</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="mi">9</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="c1">// 정의된 BFS 함수 호출</span>
<span class="nf">bfs</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[그래프 혹은 트리에서 모든 노드를 한번씩 탐색하기 위한 방법 (모든 간선의 길이가 동일할 때) 최단 거리를 탐색하기 위한 목적으로 사용할 수 있다. 큐 자료구조를 이용한다]]></summary></entry></feed>