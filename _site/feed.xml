<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-11-29T18:29:53+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gomdarachi의 기술블로그</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><entry><title type="html">HTML 개요</title><link href="http://localhost:4000/html/2023-11-29-HTML-%EA%B0%9C%EC%9A%94/" rel="alternate" type="text/html" title="HTML 개요" /><published>2023-11-29T17:59:24+09:00</published><updated>2023-11-29T18:29:53+09:00</updated><id>http://localhost:4000/html/HTML%20%EA%B0%9C%EC%9A%94</id><content type="html" xml:base="http://localhost:4000/html/2023-11-29-HTML-%EA%B0%9C%EC%9A%94/"><![CDATA[<h2 id="요소">요소</h2>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;태그&gt;</span>내용<span class="nt">&lt;태그&gt;</span> : 요소(Element) or 태그라고 부름
</code></pre></div></div>

<h2 id="빈-태그">빈 태그</h2>
<p>HTML 1/2/3/4/5는 <태그> 이렇게 썻는데,  
XHTML에서는 <태그></태그> 이렇게 엄격하게 제한 했지만  
HTML6에서는 둘다 차용했다.  
빈 태그들은 속성을 사용하는 것이 거의 사용하게 된다. br같은 예외도 있음  
**<태그></태그>** 이렇게 작성하는 것을 권장!</태그></p>

<h2 id="속성과-값">속성과 값</h2>
<p>태그에는 속성=”값”을 줄 수 있다.<br />
이는 요소안에 내용에 대한 것들을 설명하기 위하거나, 기능의 확장을 위해 사용<br />
필수 속성: 요소에게 꼭 필요한 속성</p>

<h2 id="글자와-상자">글자와 상자</h2>
<p>요소가 화면에 출력되는 특성, 크게 2가지로 나뉨</p>
<ul>
  <li>인라인(InLine)요소: 글자를 만들기 위한 요소들.
가로, 세로가 내용만큼 줄어드려고 한다.<br />
글자는 가로, 세로 사이즈를 지정할 수 없다.<br />
padding, margin 둘다 좌우만 적용된다.<br />
자식으로 블록 요소를 넣을 수 없다.</li>
  <li>블록(Block)요소: 상자(레이아웃)를 만들기 위한 요소들.
가로가 부모 요소의 크기만큼 자동으로 늘어남!<br />
가로, 세로 크기를 지정할 수 있다.<br />
margin, padding도 다 넣을 수 있다.<br />
자식으로 block도 포함 할 수 있다.</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="html" /><summary type="html"><![CDATA[요소 &lt;태그&gt;내용&lt;태그&gt; : 요소(Element) or 태그라고 부름]]></summary></entry><entry><title type="html">a 테그에 대한 정리</title><link href="http://localhost:4000/html/2023-11-29-a-%ED%85%8C%EA%B7%B8/" rel="alternate" type="text/html" title="a 테그에 대한 정리" /><published>2023-11-29T17:17:24+09:00</published><updated>2023-11-29T17:23:10+09:00</updated><id>http://localhost:4000/html/a%20%ED%85%8C%EA%B7%B8</id><content type="html" xml:base="http://localhost:4000/html/2023-11-29-a-%ED%85%8C%EA%B7%B8/"><![CDATA[<h2 id="a테그에-대한-배경">a테그에 대한 배경</h2>
<p>페이지을 나누기 위해 폴더를 따로 파서 href로 연결하는 방식<br />
나중에 배우게 될 라우터와는 다른 방법이다.</p>

<h2 id="사용법">사용법</h2>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"example/about.html"</span><span class="nt">&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/example"</span><span class="nt">&gt;</span>
// example 폴더만을 경로로 준다면 그 경로 내에 index.html파일을 찾아온다.
</code></pre></div></div>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="html" /><summary type="html"><![CDATA[a테그에 대한 배경 페이지을 나누기 위해 폴더를 따로 파서 href로 연결하는 방식 나중에 배우게 될 라우터와는 다른 방법이다.]]></summary></entry><entry><title type="html">emmet</title><link href="http://localhost:4000/frontendbasic/2023-11-29-emmet/" rel="alternate" type="text/html" title="emmet" /><published>2023-11-29T15:53:24+09:00</published><updated>2023-11-29T17:58:38+09:00</updated><id>http://localhost:4000/frontendbasic/emmet</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-29-emmet/"><![CDATA[<h2 id="emmet이란">emmet이란?</h2>
<p>html, css에 자동적으로 코드를 완성시켜주는 기능(플러그인)<br />
visualStudioCode, CodePen 등 왠만한 곳은 사용 가능</p>

<h2 id="emnet-사용법">emnet 사용법</h2>
<ul>
  <li>HTML에서
    <ul>
      <li>요소이름 + Tap</li>
    </ul>
  </li>
  <li>CSS에서
    <ul>
      <li>속성 줄임말:숫자 + Tap</li>
    </ul>
  </li>
  <li>공통
    <ul>
      <li>CSS선택자를 잘 학습해서 사용하자</li>
      <li>{}: 삽입 내용, *: 곱하기, $: 순서대로 숫자 입력</li>
    </ul>
  </li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[emmet이란? html, css에 자동적으로 코드를 완성시켜주는 기능(플러그인) visualStudioCode, CodePen 등 왠만한 곳은 사용 가능]]></summary></entry><entry><title type="html">브라우저 스타일 초기화</title><link href="http://localhost:4000/frontendbasic/2023-11-29-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%B4%88%EA%B8%B0%ED%99%94/" rel="alternate" type="text/html" title="브라우저 스타일 초기화" /><published>2023-11-29T15:45:24+09:00</published><updated>2023-11-29T17:53:27+09:00</updated><id>http://localhost:4000/frontendbasic/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EC%8A%A4%ED%83%80%EC%9D%BC%20%EC%B4%88%EA%B8%B0%ED%99%94</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-29-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%B4%88%EA%B8%B0%ED%99%94/"><![CDATA[<h2 id="초기화-하는-이유">초기화 하는 이유</h2>
<p>브라우저마다 기본 스타일이 다르기 때문에 크로스 브라우저를 하기 위해</p>

<h2 id="초기화-하는-방법">초기화 하는 방법</h2>
<ol>
  <li>구글에 reset.css cdn을 검색한다.</li>
  <li>cdnjs.com 이나 jsdelivr.com 사이트를 이용한다.</li>
  <li>reset.min.css: 파일을 필요한 것들만 압축 해 놓은 것(이용)</li>
  <li>link테그를 이용해 스타일을 초기화 한다(모든 CSS적용보다 앞서 작성해야한다!!)</li>
</ol>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[초기화 하는 이유 브라우저마다 기본 스타일이 다르기 때문에 크로스 브라우저를 하기 위해]]></summary></entry><entry><title type="html">CodePen 알아보기</title><link href="http://localhost:4000/frontendbasic/2023-11-29-CodePen-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="CodePen 알아보기" /><published>2023-11-29T15:37:24+09:00</published><updated>2023-11-29T17:49:52+09:00</updated><id>http://localhost:4000/frontendbasic/CodePen%20%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-29-CodePen-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/"><![CDATA[<p><a href="https://codepen.io">Code Pen 사이트</a><br />
간단하게 html, css, js를 테스트 해 볼수있는 사이트</p>

<h2 id="유용한-정보">유용한 정보</h2>
<ul>
  <li>HTML은 Body부분을 코딩하는 것</li>
  <li>자바스크립트는 개발자 도구를 열어 확인</li>
  <li>모든 영역은 각각 설정이 있고,  특히 js는 외부 라이브러리도 가져오기 가능</li>
  <li>CSS설정 -&gt; CSS Base -&gt; Reset설정</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[Code Pen 사이트 간단하게 html, css, js를 테스트 해 볼수있는 사이트]]></summary></entry><entry><title type="html">상대 경로와 절대 경로</title><link href="http://localhost:4000/frontendbasic/2023-11-29-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C%EC%99%80-%EC%A0%88%EB%8C%80-%EA%B2%BD%EB%A1%9C/" rel="alternate" type="text/html" title="상대 경로와 절대 경로" /><published>2023-11-29T15:33:24+09:00</published><updated>2023-11-29T16:56:12+09:00</updated><id>http://localhost:4000/frontendbasic/%EC%83%81%EB%8C%80%20%EA%B2%BD%EB%A1%9C%EC%99%80%20%EC%A0%88%EB%8C%80%20%EA%B2%BD%EB%A1%9C</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-29-%EC%83%81%EB%8C%80-%EA%B2%BD%EB%A1%9C%EC%99%80-%EC%A0%88%EB%8C%80-%EA%B2%BD%EB%A1%9C/"><![CDATA[<h2 id="상대-경로">상대 경로</h2>
<ul>
  <li>./(본인기준), ../(자신의 위)<br />
./는 생략이 가능하다 (./images/heropy.png) === (images/heropy.png)</li>
</ul>

<h2 id="절대-경로">절대 경로</h2>
<ul>
  <li>http(https) 원격, /<br />
root(index.html 파일이 있는 경로)</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[상대 경로 ./(본인기준), ../(자신의 위) ./는 생략이 가능하다 (./images/heropy.png) === (images/heropy.png)]]></summary></entry><entry><title type="html">HTML 문서의 구조</title><link href="http://localhost:4000/frontendbasic/2023-11-28-HTML-%EB%AC%B8%EC%84%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="HTML 문서의 구조" /><published>2023-11-28T14:22:24+09:00</published><updated>2023-11-28T19:13:43+09:00</updated><id>http://localhost:4000/frontendbasic/HTML%20%EB%AC%B8%EC%84%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-28-HTML-%EB%AC%B8%EC%84%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0/"><![CDATA[<h2 id="전체-구조">전체 구조</h2>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>

  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>

  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h2 id="doctype에-대한-설명">DOCTYPE에 대한 설명</h2>
<p>DTD(Document Type Definition): 문서 타입 정의</p>
<ol>
  <li>html1</li>
  <li>html2</li>
  <li>html3</li>
  <li>html4</li>
  <li>htmlx</li>
  <li>html5(웹 표준)</li>
</ol>

<ul>
  <li>html1~4는 사용할 일 없고, XHTML정도 유지보수 관점에서 만나볼수 있는데
&lt;!DOCTYPE hmtl PUBLIC “-//W3C//DTD XHTML 1.0 Tras….”&gt; 이렇게 생김</li>
  <li><strong>html테그</strong>는 브라우저에게 문서의 전체 범위를 알려주는데 사용</li>
  <li><strong>head테그</strong>는 웹 페이지에 보이지 않는 문서의 정보를 나타내는 범위</li>
  <li><strong>body테그</strong>는 웹 페이지에서 보여지는 문서의 구조를 나타내는 범위</li>
</ul>

<h2 id="css-js를-html문서로-가져오는-방식">CSS, JS를 HTML문서로 가져오는 방식</h2>
<ul>
  <li><strong>CSS를 연결하는 방식</strong>
    <ul>
      <li>
        <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"./main.css"</span><span class="nt">&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>JS를 연결하는 방식</strong>
    <ul>
      <li>
        <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"./main.js"</span> <span class="nt">/&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="정보를-의미하는-테그들">정보를 의미하는 테그들</h2>
<ul>
  <li>title: 웹의 제목을 정함</li>
  <li>link: CSS, Icon과 같은 외부 파일을 가져올떄 사용
    <ul>
      <li>rel: 관계</li>
      <li>href: 경로</li>
      <li>웹 사이트 로고 만들기
        <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"icon"</span> <span class="na">href=</span><span class="s">"./favicon.png"</span><span class="nt">&gt;</span>
    
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>meta 테그: title, link, style, script로 나타낼수 없는 정보를 표시
    <ul>
      <li>기본 구성 name: 어떤 속성?, content: 내용</li>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;meta name="viewport" width="device-width, initial-scale=1.0"&gt;
</code></pre></div>        </div>
        <p>뷰 포트는 모바일 환경에서만 사용됨. initial-scale은 모바일에서 화면 기본 확대 설정</p>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[전체 구조 ```html &lt;!DOCTYPE html&gt;]]></summary></entry><entry><title type="html">VisualStudioCode의 단축키</title><link href="http://localhost:4000/frontendbasic/2023-11-21-VisualStudioCode%EC%9D%98-%EB%8B%A8%EC%B6%95%ED%82%A4/" rel="alternate" type="text/html" title="VisualStudioCode의 단축키" /><published>2023-11-21T21:11:24+09:00</published><updated>2023-11-28T14:21:50+09:00</updated><id>http://localhost:4000/frontendbasic/VisualStudioCode%EC%9D%98%20%EB%8B%A8%EC%B6%95%ED%82%A4</id><content type="html" xml:base="http://localhost:4000/frontendbasic/2023-11-21-VisualStudioCode%EC%9D%98-%EB%8B%A8%EC%B6%95%ED%82%A4/"><![CDATA[<h2 id="기본-단축키">기본 단축키</h2>
<ul>
  <li>ctrl + shift + p: 커맨드 창 열기</li>
  <li>ctrl + o: 폴더 열기</li>
  <li>프로젝트 단위는 파일이 아닌 폴더(디렉토리) 개념이다.</li>
  <li>!+탭 or 엔터: html의 기본구조 자동 완성</li>
  <li>테그명+tap: 자동완성</li>
  <li>파일 개별 저장은 파일명 옆에 동그라미가 사라지고 X로 바뀌면 완성</li>
  <li>프로젝트 단위 저장은 Ctrl+Alt+S</li>
  <li>ctrl+h: 찾은 단어들 바꾸기 또는 모두 바꾸기</li>
  <li>Alt+up,down: 줄을 위, 아래로 올리기</li>
  <li>shift+tap: 내려쓰기(out dent)</li>
  <li>전부다 모아서 shift+tap하면 전체 내려쓰기 가능</li>
  <li>ctrl+shift+[,]: 탭 앞,뒤로 이동하기</li>
</ul>

<h2 id="개발을-위한-기본-세팅extension">개발을 위한 기본 세팅(Extension)</h2>
<ul>
  <li>korean language: 한글화</li>
  <li>beautify: 코드 깔끔하게 만들기
    <ul>
      <li>ctrl + shift + p -&gt; 바로가기 -&gt; HookyQ.beautify -&gt; 단축키 설정</li>
    </ul>
  </li>
  <li>auto rename tag: 자동으로 테그명 앞 뒷 맞춰주기</li>
  <li>live server: 실시간으로 웹 프로젝트 브라우저로 출력 가능</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="frontendBasic" /><summary type="html"><![CDATA[기본 단축키 ctrl + shift + p: 커맨드 창 열기 ctrl + o: 폴더 열기 프로젝트 단위는 파일이 아닌 폴더(디렉토리) 개념이다. !+탭 or 엔터: html의 기본구조 자동 완성 테그명+tap: 자동완성 파일 개별 저장은 파일명 옆에 동그라미가 사라지고 X로 바뀌면 완성 프로젝트 단위 저장은 Ctrl+Alt+S ctrl+h: 찾은 단어들 바꾸기 또는 모두 바꾸기 Alt+up,down: 줄을 위, 아래로 올리기 shift+tap: 내려쓰기(out dent) 전부다 모아서 shift+tap하면 전체 내려쓰기 가능 ctrl+shift+[,]: 탭 앞,뒤로 이동하기]]></summary></entry><entry><title type="html">그래프 문제를 풀 때 인접 배열이냐.. 인접 리스트냐…</title><link href="http://localhost:4000/algorithm/2023-11-21-%EC%9D%B8%EC%A0%91-%EB%B0%B0%EC%97%B4%EC%9D%B4%EB%83%90/-%EC%9D%B8%EC%A0%91-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%83%90/" rel="alternate" type="text/html" title="그래프 문제를 풀 때 인접 배열이냐.. 인접 리스트냐…" /><published>2023-11-21T20:52:24+09:00</published><updated>2023-11-21T20:53:09+09:00</updated><id>http://localhost:4000/algorithm/2023-11-21-%EC%9D%B8%EC%A0%91-%EB%B0%B0%EC%97%B4%EC%9D%B4%EB%83%90/%EC%9D%B8%EC%A0%91%20%EB%B0%B0%EC%97%B4%EC%9D%B4%EB%83%90..%20%EC%9D%B8%EC%A0%91%20%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%83%90</id><content type="html" xml:base="http://localhost:4000/algorithm/2023-11-21-%EC%9D%B8%EC%A0%91-%EB%B0%B0%EC%97%B4%EC%9D%B4%EB%83%90/-%EC%9D%B8%EC%A0%91-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%83%90/"><![CDATA[<h2 id="각-방식의-특징과-장단점">각 방식의 특징과 장단점</h2>

<h2 id="다익스트라">다익스트라</h2>

<h2 id="플로이드-와샬">플로이드 와샬</h2>

<h2 id="벨만-포드">벨만 포드</h2>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[각 방식의 특징과 장단점]]></summary></entry><entry><title type="html">다익스트라 알고리즘 In JS</title><link href="http://localhost:4000/algorithm/2023-11-21-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCJS/" rel="alternate" type="text/html" title="다익스트라 알고리즘 In JS" /><published>2023-11-21T17:54:24+09:00</published><updated>2023-11-21T20:50:11+09:00</updated><id>http://localhost:4000/algorithm/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCJS</id><content type="html" xml:base="http://localhost:4000/algorithm/2023-11-21-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCJS/"><![CDATA[<h2 id="다익스트라-알고리즘이란">다익스트라 알고리즘이란?</h2>
<p>음의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘</p>

<h2 id="시간-복잡도">시간 복잡도</h2>
<p>O(\(V^2\))인데, 우선순위 큐를 활용해 개선 된 다익스트라 알고리즘에선 O((V+E)logV)로 개선 됨.</p>
<ul>
  <li>V는 정점의 개수, E는 한 정점의 주변 노드</li>
</ul>

<h2 id="동작-과정그림">동작 과정(그림)</h2>
<p><img src="../images/DijkstraAlgorithmProcedure(1).jpg" alt="다익스트라 동작 과정(1)" />
<img src="../images/DijkstraAlgorithmProcedure(2).jpg" alt="다익스트라 동작 과정(2)" />
<img src="../images/DijkstraAlgorithmProcedure(3).jpg" alt="다익스트라 동작 과정(2)" />
<img src="../images/DijkstraAlgorithmProcedure(4).jpg" alt="다익스트라 동작 과정(2)" />
<img src="../images/DijkstraAlgorithmProcedure(5).jpg" alt="다익스트라 동작 과정(2)" /></p>

<h2 id="코드로-이해">코드로 이해</h2>
<h3 id="기본-구현-인접-배열-방식">기본 구현 [인접 배열 방식]</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="c1">// 인접 배열 초기화</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span> <span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>

<span class="c1">// 방문 여부 체크할 배열</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="c1">// 1번 노드로부터 각 노드까지의 최단 거리를 저장한 배열 생성</span>
<span class="kd">const</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span>

<span class="c1">// 방문하지 않았으면서 거리 테이블에서 가장 작은 값을 가진 노드 탐색</span>
<span class="kd">const</span> <span class="nx">findSmallestNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">visited</span><span class="p">,</span> <span class="nx">dist</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">minDist</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">minIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">dist</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">dist</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">minDist</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">minDist</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="nx">minIdx</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">minIdx</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 다익스트라 알고리즘 수행</span>
<span class="kd">const</span> <span class="nx">dijkstra</span> <span class="o">=</span> <span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">dist</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 시작 노드는 0으로 초기화</span>
    <span class="nx">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">dist</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">nodeIndex</span> <span class="o">=</span> <span class="nf">findSmallestNode</span><span class="p">(</span><span class="nx">visited</span><span class="p">,</span> <span class="nx">dist</span><span class="p">);</span>
        <span class="nx">visited</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="nx">dist</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
            <span class="nx">dist</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">dist</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dist</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">]</span><span class="o">+</span><span class="nx">graph</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">][</span><span class="nx">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">dijkstra</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span><span class="nx">visited</span><span class="p">,</span><span class="nx">dist</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">dist</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>코드를 확인해보면 가장 dist중에 가장 작은 값을 가진 노드를 찾는데 N</li>
  <li>그 노드와 인접한 노드 + 그 노드까지 거리 or 목적지 노드까지 거리 중 최소 값을 구하는데 N해서 
\(N^2\)의 시간복잡도를 가지는 것을 알 수 있다.
    <h3 id="우선순위-큐-활용-구현-인접-리스트-방식">우선순위 큐 활용 구현 [인접 리스트 방식]</h3>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 우선순위 큐 클래스 정의</span>
<span class="kd">class</span> <span class="nc">PriorityQueue</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="nf">enqueue</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">priority</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">priority</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nf">sort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">shift</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nf">sort</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">priority</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">priority</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="c1">// 인접 배열 초기화</span>
<span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span> <span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">[</span><span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>

<span class="c1">// 방문 여부 및 최단 거리 테이블 초기화</span>
<span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">dist</span> <span class="o">=</span> <span class="nc">Array</span><span class="p">(</span><span class="nx">N</span><span class="p">).</span><span class="nf">fill</span><span class="p">(</span><span class="kc">Infinity</span><span class="p">);</span>

<span class="c1">// 시작 노드는 0으로 초기화</span>
<span class="nx">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 우선순위 큐 초기화</span>
<span class="kd">const</span> <span class="nx">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="p">();</span>
<span class="nx">pq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 시작 노드는 0으로 초기화</span>
<span class="nx">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 다익스트라 알고리즘 수행</span>
<span class="kd">const</span> <span class="nx">dijkstra</span> <span class="o">=</span> <span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">visited</span><span class="p">,</span> <span class="nx">dist</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 시작 노드는 0으로 초기화</span>
    <span class="nx">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">while </span><span class="p">(</span><span class="o">!</span><span class="nx">pq</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="na">element</span><span class="p">:</span> <span class="nx">nodeIndex</span><span class="p">,</span> <span class="na">priority</span><span class="p">:</span> <span class="nx">currentDistance</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">pq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span>

        <span class="k">if </span><span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="nx">visited</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">dist</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

            <span class="kd">const</span> <span class="nx">newDistance</span> <span class="o">=</span> <span class="nx">currentDistance</span> <span class="o">+</span> <span class="nx">graph</span><span class="p">[</span><span class="nx">nodeIndex</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>

            <span class="k">if </span><span class="p">(</span><span class="nx">newDistance</span> <span class="o">&lt;</span> <span class="nx">dist</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">dist</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newDistance</span><span class="p">;</span>
                <span class="nx">pq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">newDistance</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">dijkstra</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span><span class="nx">visited</span><span class="p">,</span><span class="nx">dist</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">dist</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>방문 하지 않은 node들중 dist값이 가장 작은 node를 선택 하는 부분을 우선순위 큐로 바꿈.</li>
  <li>해당 과정에서 findSmallestNode()함수는 필요 없게 됨.</li>
</ul>]]></content><author><name>&lt;Kim&gt; &lt;SunWoo&gt;</name><email>&lt;ttcoristory@naver.com&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA[다익스트라 알고리즘이란? 음의 가중치가 없는 그래프의 한 정점에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘]]></summary></entry></feed>