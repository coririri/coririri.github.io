---
layout: post
title:  "숫자형"
date:   2024-01-11 18:30:24 +0900

---
# 숫자형
모던 js는 숫자를 나타내는 두 가지 자료형을 지원한다.
1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장됩니다
2. 일반적인 숫자는 253이상이거나 -253이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌습니다

## 숫자의 표현 방법들

```javascript
let billion = 1000000000;
let billion = 1e9;  // 10억, 1과 9개의 0
// 1e3 === 1 * 1000
// 1.23e6 === 1.23 * 1000000

let ms = 0.000001;
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동

// 1e-3 === 1 / 1000 // 0.001
// 1.23e-6 === 1.23 / 1000000 // 0.00000123

// 16진수, 2진수, 8진수
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다.)

let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

// 자바스크립트에서 지원하는 진법은 3개입니다. 이 외의 진법을 사용하려면 함수 parseInt를 사용

// toString(base)

let num = 22;
alert(num.toString(16)) //ff
alert(num.toString(2)) //11111111

// base=16 - 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다
// baase=2 - 비트 연산 디버깅에 주로 쓰입니다.
// base=36 - 36 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다.
```
- 점 두개와 메서드 호출

```javascript
123456..toString(36)
// 숫자를 대상으로 메서드 toString을 직접 호출하고 싶다면 숫자 다음에 점 두 개 ..를 붙여야 합니다.
// 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러
// (123456).toString(36)도 가능합니다.
```


## 유의 해야할 만한 내용들
- 어림수 구하기
1. Math.floor 
소수점 첫째 자리에서 내림(버림). 3.1은 3, -1.1은 -2가 됩니다.
2. Math.ceil
소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 됩니다.
3. Math.round
소수점 첫째 자리에서 반올림. 3.1은 3, 3.6은 4, -1.1은 -1이 됩니다.
4. Math.trunc (Internet Explorer에서는 지원하지 않음)
소수부를 무시. 3.1은 3이 되고 -1.1은 -1이 됩니다.

- n-th번째 수를 기준으로 어림수를 구하기
1. 곱하기와 나누기
소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 됩니다.

```javascript
let num = 1.23456;
alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
```

- 부동 소수점의 부정확성
IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 무한소수를 표기합니다  
'작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.
- 해결 방안

```javascript
// toFixed사용하기
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.30

// 숫자에 임시로 곱하고 나눠주기
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

- NaN과 Infinity
1. isNaN(value) – 인수를 숫자로 변환한 다음 NaN인지 테스트함
if(number === NaN)로 대체하면 안되나??  

```javascript
//  NaN은 NaN 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특합니다.
alert( NaN === NaN ); // false
```
2. isFinite(value) – 인수를 숫자로 변환하고 변환한 숫자가 NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우 true를 반환함

```javascript
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, NaN이기 때문입니다.
alert( isFinite(Infinity) ); // false, Infinity이기 때문입니다.

// 빈 문자열이나 공백만 있는 문자열은 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의
```

## 더 정확한 비교
Object.is는 ===처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데,  
아래와 같은 두 가지 에지 케이스에선 ===보다 좀 더 신뢰할만한 결과를 보여줍니다.
1. NaN을 대상으로 비교할 때: Object.is(NaN, NaN) === true임.
2. 0과 -0이 다르게 취급되어야 할 때: Object.is(0, -0) === false임

## parseInt와 parseFloat
단항 덧셈 연산자 + 또는 Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격합니다  
피연산자가 숫자가 아니면 형 변환이 실패합니다.

```javascript
  alert( +"100px" ); // NaN
```
그런데 실무에선 CSS 등에서 '100px', '12pt'와 같이 숫자와 단위를 함께 쓰는 경우가 흔합니다.  
내장 함수 parseInt와 parseFloat는 이런 경우를 위해 만들어졌습니다.  
두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’.

```javascript
  alert( parseInt('100px') ); // 100
  alert( parseFloat('12.5em') ); // 12.5
```

## 기타 수학 함수
1. Math.random()
0과 1 사이의 난수를 반환합니다(1은 제외).
2. Math.max(a, b, c...) / Math.min(a, b, c...)
인수 중 최대/최솟값을 반환합니다.
3. Math.pow(n, power)
n을 power번 거듭제곱한 값을 반환합니다.

